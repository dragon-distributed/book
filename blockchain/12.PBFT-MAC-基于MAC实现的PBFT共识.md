# PBFT-MAC 基于MAC实现的PBFT共识
(本文属于原创内容，首发于https://github.com/dragon-distributed/book , 未经作者许可，不得转载。)  

## 概述

基于MAC实现的PBFT，是对基于数字签明的一种优化。在OSDI的paper中只是简要描述，在作者的博士论文中有具体的描述，其实在MIT的另一篇paper：<\<Authenticated Byzantine Fault Tolerance Without Public-Key Cryptography>> 也有具体的描述，但是paper之间的实现方式并不太一样，特别是在view change的实现，但背后的思路是一样的。  

本文打算从PBFT-MAC与PBFT-PK的不同点出去，去了解PBFT-MAC的核心思想。  

## 什么是MAC

MAC是Message Authentication Code的缩写，抄自wiki的图：

![图1](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/12.mac.jpg)

Message Authentication Code主要有两个功能：  
(1) 检查消息完整性：它可以用来检查在消息传递进程中，其内容是否被更改过   
(2) 身份验证：确认消息的来源   

## 为什么提出PBFT-MAC

主要是由于性能问题，正如paper中指出，数字签名的性能与MAC性能数量级别的差距，生成一个1024bit RSA签名需要用42ms时间，但生成MAC则需要10.3us。这是2000年的paper，我们不纠结这个数据对不对，或者签名是不是有其它算法，随着类Algorand的项目推出，大家对其使用的数字签名性能，以及签名数据量不断提出challenge。  

## 从PBFT-PK到PBFT-MAC，只是换了个消息加密方式吗

可能有人会问，从PBFT-PK到PBFT-MAC，就是换了个消息的加密方式，没其它事情要做了。其中不然，从PBFT-PK到PBFT-MAC，最大的问题是，proof失效了。  

![图2, proof](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/12.challenge.jpg)

从图上看，如果是PBFT-PK，signature message是可以给其它三方验证的，就好比你有一份购房合同，上面有印章，是有法律效应的，给其它人看，其它人是会相信的。但PBFT-MAC则不一样，假设A给B发消息(通过MAC)，B能相信A，但C是不会相信的。所以使用PBFT-MAC，套到原来PBFT-PK流程，其中的需要proof的地方，就会出问题。  

## PBFT-MAC的核心思路

本人的理解，PBFT-MAC的核心思路是lazy proof，即：  
(1) MAC in Normal Case：即正常的流程下，走MAC，保证性能  
(2) Lazy Proof：using digital signatures lazily only when they need，eg: checkpoint, view change。  

## PBFT-MAC Normal operation的改动

![图3, normal operation改动](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/12.normal.jpg)

如上图，client要将request，以不同的MAC，发送到不同的replica中（这里可以先别急着说优化^_^）。为什么需要这样子呢？这是因为，backups需要确认，这个request的身份信息以及完整性，如果只是从primary发送给backup，backups是无法确认这个request是否被篡改。  

优化方案是有很多种，比如request只发给primary，但request中需要包括client与每个backups的MAC值，这样backup在收到primary的request后，能通过自己的MAC值确认request。还有优化如，client只发full request到primary，但给backups只发MAC等，原理都是一样的。  

## PBFT-MAC Garbage Collection的改动

简单来说，GC的改动，由原来的f+1，变为2f+1。其背后原因是lazy proof，在view change时，某个replica需要广播view change消息，这个消息需要提供stable checkpoint proof，我们知道，这个proof需要f+1个signature checkpoint消息。  

但是PBFT-MAC没有任务的proof，这时，就需要去其它节点拿proof，即向其它节点请求checkpoint signature信息。如果先前stable checkpoint是由2f+1产生的，那么，在后面去拿proof时，最少也能拿到f+1的signature checkpoint消息，这保证了后面需要时，能提供proof。  

## PBFT-MAC View Change的改动

MAC的View Change也是PBFT-MAC中最难的部分。我们回头PBFT-PK的实现，new primary需要知道集群的全局视图，所以每个节点发送view change时，需要带上stable checkpoint以及checkpoint的proof，并且需要checkpoint后面的每个Sequence Number的处理方案(有request or no-op)。  

对于PBFT-MAC来说，stable checkpoint有，但是proof没有，那就需要用lazy proof的方式，在需要做view change时，先拿到proof，方法就是先往其它节点发送check-sig消息：

![图4, check-sig](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/12.lazy%20proof.jpg)

意思是让其它节点返回一个签名的checkpoint消息。正如上述GC章节点提到，因为stable checkpoint的产生需要2f+1，所以这时，最少会有f+1个节点能返回正确的checkpoint的signature，所以在view change时，节点是能提供checkpoint的proof的。  

但是checkpoint后面，对应Sequence Number的request，却拿不到proof了，这怎么办？解决办法是，每个节点只处理自己的，为每个Sequence Number对应的pre-prepare, prepare message进行签名，然后让new primary去统计，达到 1 pre-prepare + 2 prepare message的，则认为这个Sequence Number对应的request是有效的，否则补no-op。  

其实，论文最后也提到，stable checkpoint也可以交由new primary去统计，那就省去了check-sig的交互，具体做法是，每个节点，对自己的stable checkpoint进行签名，由new primary去全局观察做决定。  

## 总结

PBFT-MAC的优势在于性能上，它的核心在于Lazy Proof，normal case operation使用MAC，在少量的场景，如view change再使用数字签名进行proof。  