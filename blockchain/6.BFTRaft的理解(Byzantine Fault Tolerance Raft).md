# BFT Raft的理解 (Byzantine Fault Tolerant Raft)
(本文属于原创内容，首发于https://github.com/dragon-distributed/book , 未经作者许可，不得转载。)  

## 背景

上篇文章介绍了PBFT，后来灵机一动，在传统的分布式领域，是否有支持Byzantine的一致性算法呢？于是搜索到了Byzantine Fault Tolerant Raft这篇paper（paxos早就有了）。这篇paper是在2018年在斯坦福大学刊登的。看来随着区块链的流行，越来越多人在聚焦。  
这篇paper在保留了Raft的简单、可懂的基础上（个人认为Raft的优点在于paper上的流程已很清晰，在工程落地时有着严格的约束），通过加强（修改）Raft的一些流程，达到支持Byzantine的环境。  

## Raft在Byzantine的环境会遇到什么问题

使用传统的Raft，在Byzantine环境会遇到什么问题呢？我们来列一下：

A) 首先，Raft是强Leader的一致性算法，那么如果Leader是作恶节点，会出现什么问题？  
    a1) Leader可能会篡改用户的请求，使整个集群数据错乱。  
    a2) Leader可能会重复用户的请求，造成数据异常。     
    a3) Leader可能会直接丢弃用户请求，使整个集群无法正确服务。  
    a4) Leader可能会"撒谎"，存储的log与其广播的不一致，破坏多数派。  
    a5) Leader可能会发送错误的commit消息，导致数据异常。  
B) 如果slave节点是作恶节点，会出现什么问题？  
    b1) slave的作恶节点，可能会不断地发起leader election，导致集群无法正常服务。  
(PS:但在成熟的Raft实现中，如etcd/baidu/hashicorp raft，集群在正常状态下，不响应vote请求)    
    b2) slave如何确认leader是leader。  
    b3) slave可能会"撒谎"，存储的log与其广播的不一致，破坏多数派。  

下文将逐个解决上述问题，在了解如何解决后，对BFT Raft也有个比较深入的了解。


## Raft如何解决Byzantine环境的问题

### Leader可能会篡改用户的请求，使整个集群数据错乱

因为数据流是client<->leader<->slave的，client如何确认leader的回复是针对未被篡改的请求，如何保证leader不会篡改数据，这里需要用到签名：  

**Client Signature：**  client使用自己的私钥对request进行签名，这样的话：  
a) slave可以使用公钥对leader的同步请求进行校验；  
b) nodes在ack client时，需要带上签名，表示是对此请求的响应。  
通过签名，可以保证leader无法篡改数据而不被发现。  

### Leader可能会重复用户的请求，造成数据异常

**unique identifier：**  这个比较容易处理，就是在客户端，生成一个unique identifier，并piggyback在request中，client在签名时，包含此identifier。这样子的话，identifier无法被leader篡改，而nodes又可以过滤掉相同identifier的请求。

### Leader可能会直接丢弃用户请求，使整个集群无法正确服务

**client intervention：**  client如果在一段时间内(called process timeout)，发现leader老不处理它的请求，那么，client有权力发出UpdateLeader的RPCs请求到所有的nodes，启动update leader操作。  

PS: 在实现中，需要考虑是因为其它原因导致的异常，还是leader作恶导致的异常。  


### Leader可能会"撒谎"，存储的log与其广播的不一致，破坏多数派

这里涉及到几个问题。

1) **Log对比逻辑：** 传统的raft，两个节点，如果相同的term与index对应的数据相同，那么[0,index]的数据，也是被认为想同的。但在Byzantine的情况则不同，作恶节点可能会丢弃数据，篡改数据，重排数据，重复数据等，所以这种判断逻辑是不适用的，在paper提出了一个incremental hashing。  

**incremental hashing：** 这个思路跟区块链中的hash是一样的，也就是N index的data，记算hash，然后这个hash会放入N+1 index data里面，做成一个hash链。这样的话，只要相同的index的hash是一致的话，前面所有的entry则是一致的。  

通过incremental hashing，可以解决作恶节点存储错误的数据而不被发现。

2) **破坏多数派：**  传统的raft是n=2f+1，而在Byzantine的环境下，与PBFT一样，需要n=3f+1，而且client也跟PBFT一样，需要等待f+1的ack。为什么是这样，可以参考本人的上一篇文章[PBFT的理解](https://github.com/dragon-distributed/book/blob/master/blockchain/5.PBFT的理解(Practical%20Byzantine%20Fault%20Tolerance).md)。通过这个保证，至少有多数派的节点达成了共识。    


### Leader可能会发送错误的commit消息，导致数据异常

传统的raft是Leader说了算，所以如果Leader是作恶节点，那么commit index也是不可信的。BFT Raft采用了与PBFT一样的思路：  

**commit verification：** 节点的commit不再是听只leader的。当每个replica(包括leader)，收到AppendEntries，处理完之后，回复AppendEntriesResponse不再是只回leader，而是广播到所有节点。当节点收到多数派个数的response后，可以直接认为是commit了。(PS：这里的多数派个数paper没见，个人理解是2f+1，包括自己)  

### slave的作恶节点，可能会不断地发起leader election，导致集群无法正常服务

**lazy voters：** paper中提出lazy voters解决这个问题，其实传统的raft中都有实现，也就是当节点认为集群正常时，不会响应vote的请求。 

### slave如何确认leader是leader

如果一个作恶节点，直接发送AppendEntries with higher term，那怎么办？  
在传统的raft工程实现中，leader是会有租约的，如果他在一定时间内，发现"活"着的节点数达不到quorum，则会自动降级。在Byzantine的环境下，一方面可以保留此种实现，另一方面，如何才能保证leader是真正的leader呢？  

(PS:传统的vote，是vote给replica id，但在Byzantine的情况下，这是可以伪造的，也就是一个作恶节点，他可以伪装自己是这个replica id)

**Election verification：** paper中提出，在node变成leader之后，第一个AppendEntires Request，需要带上vote的证据，以便slave能辨别此leader是leader...，后续的RPC请求，则不需要带上。但是，slave有权要求leader再次发送vote证据，比如在slave重启之后，他可以要求leader再次发送vote证据，证明自己。

### slave可能会"撒谎"，存储的log与其广播的不一致，破坏多数派

同Leader"撒谎"。

## 总结

上面讲述了传统的Raft算法，放在Byzantine环境下，可能会遇到的问题，以及如何解决这些问题，将这些解决办法综合，则是BFT Raft算法的核心。  

个人理解，BFT Raft还是有局限性的，比如：  
1) 使用场景：在可控的场景，如私链，公司内部的分布式系统，用Raft更简单、成本更低。在广域网的场景，强Leader的算法比较容易受攻击，也不容易用于随机选子集的思路。  
2) 通讯问题：BFT Raft中，如Election verification流程，假定是TCP通讯，但在广域网的场景，更多的是UDP，可能有一些算法流程会涉及到改动。



 