# PBFT的理解二: normal-case operation
(本文属于原创内容，首发于https://github.com/dragon-distributed/book , 未经作者许可，不得转载。)  

## 概述

本文重点讲解PBFT的normal case operation的部分，也是PBFT比较简单的部分，重难点在于理解为什么。  

## Normal Case Operation

normal case operation表达了在正常情况下，从client发送请求，到达成共识，到response的过程。  

共识流程主要有五个步骤，paper写得比较清楚，如下图：

![图1](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/5.pbftprocess.jpg)

a) **client发送请求到primary**：这里的关键问题是理解signature的作用。在Byzantine的环境下，每个节点都不相信其它节点，消息都需要签名（PBFT还有基于MAC的实现，这里不展开）。client的签名主要用于：
* 用于Primary对request的身份验证，以及request的完整性验证
* 用于Backup对Primary发起的pre-prepare进行验证，主要是pre-prepare message中的request的身份验证（是否是client发起来），primary是否有篡改client的request。  

顺带说一句，签名是针对request的digest签的，而不是针对整个message签的，这是出于性能考虑。  


b) **pre-prepare:** 一旦primary收到request，它会(存储log那部分不展开)：  
* 给request定序(the primary assigns a sequence number, n , to the request)  
* 广播pre-prepare(包括view number(类似raft term), sequence number(类似raft index), request, 签名等信息)

值得注意的是，一旦primary广播pre-prepare message，意味着primary是接受这个request，以及接受request对应的sequence number的，也就是pre-prepare可以代表primary的prepare意图，这是后面为什么prepare阶段为什么只需要2f的原因所在。  

c) **prepare:** 其它backups收到pre-prepare message之后，会进行校验。如果校验通过，则会广播prepare message到其它节点。  

这里的校验有个值得注意的地方，就是 h<n<H，其中h是stable checkpoint的sequence number，H是c*k，k是指每多少个sequence number生成checkpoint，c是个常量，在工程实现中自己定义。主要用于规定sequence number的范围，为了防止faulty primary把sequence number耗尽。  

d) **commit:** 当某个backup收到包括自己的2f个有效的prepare消息之后，从这个backup视角，它认为prepare已达到多数派（因为默认primary是同意的），它开始广播commit消息。同时，拥有2f prepare消息的状态，称为prepare certificate。  
  
e) **reply**：当backup收到包括自己的2f+1个有效的commit消息后，进行apply(状态机执行)，并reply给client，这跟raft的apply是一样的。client收到f+1个相同的response之后，即可认为此request正确执行。为什么是f+1，请参考()。    

## 总结

normal case operation表达了在正常情况下，从client发送请求，到达成共识，到response的过程。流程不难，能理解原理更好。比如问自己，为什么要commit阶段，如果很容易就回答出来，证明理解了。    












