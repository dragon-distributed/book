# VRF 以及 VRF在Algorand中的应用 

(本文属于原创内容，首发于https://github.com/dragon-distributed/book , 未经作者许可，不得转载。)  

## 概述

VRF(Verifiable Random Function)，是在1999年提出的。随着最近Algorand的大热(好多钱哇...)，VRF也越来越被大家熟悉。

本文计划先介绍VRF，然后介绍VRF在Algorand中的使用。由于非密码学科班出生，本文不涉及VRF密码学推导相关知识。

VRF的paper可以在[这里](https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Pseudo%20Randomness/Verifiable_Random_Functions.pdf) 获取，最新的规范draft-irtf-cfrg-vrf-version03可以在[这里](https://tools.ietf.org/html/draft-goldbe-vrf-01.html) 获取。

## 一个问题

假设有一公司的老板，最近在学习区块链，觉得很潮流，于是，决定今年的年终奖通过"抽奖"的方式抽取1等奖。于是，他印了10W张券(公司有10W员工)发给员工，每用券上有个20位随机的数字y，想使用HASH(y)抽奖。由于担心老鼠仓，所以在年会的当天，他随机生成了字符串X，然后规则是：  
> SHA256(y+X+本人的三围)=result，若result以00000开头的，即是今年的1等奖。  

由于1等奖很诱人(100亿美金)，所以中奖者非常纠结要不要去领奖，有几个问题：
1) 由于hash不可逆，所以中奖者不公布自己result的话，是无法证明是自己中奖。
2) 中奖者不想公布自己的原始数据(y+X+本人的三围)：因为有可能被人仿照或杀人灭口（比如做出一样的抽奖券、在中奖者拿着原始数据去领奖时被KO(干掉)等），有些女同学也不想三围被别人知道。

由于生命价更高，中奖者也不去领奖了，弄到老板年会开不下去。  

## VRF

第二年老板聪明了，因为他学会了VRF(Verifiable Random Function)，既然员工不想公开他的原始数据，但老板又得知道是不是他中奖，那就使用VRF吧。

第二年，老板做了三件事情：

1) 让员工根据自己的三围，生成一对非对称密钥，VK(公钥)与SK(私钥)，让员工把公钥报上公司，私钥自己放在家里。
> Keygen(r) → (VK, SK). 这里，r是三围数据  

2) 在年会的当天，老板又生成了一个随机字符串alpha，让员工用自己的SK(私钥)，以及alpha(随机字符串)，生成一个随机HASH beta，并使用VRF_prove算法成生prove pi。中奖规则是beta以5个0开头的中奖。
> beta = VRF_hash(SK, alpha)
> pi = VRF_prove(SK, alpha)

3) 中奖者要将生成的hash beta，以及prove pi，交到老板那，老板用之前员工上交的VK，校验是否是这个员工的，并且是否用alpha生成的beta。
>  VRF_verify(PK, alpha, pi)

这样子，中奖者不需要公开自己的SK(私钥)，他也不担心别人伪造（因为别人不知道他的SK），被KO后，别人也拿不到奖金（老板的VK校验不过）。

到这里，VRF的应用场景，与使用流程已经介绍完了。对于VRF中的"随机"，是指：一个理想的哈希函数，其值域应该是离散、均匀分布的，给定不同的输入值，其输出值应该随机的分布在值域区间内。

## VRF在Algorand中的应用

在区块链"不可能的三角"的情况下，Algorand选择了一种更倾向于中心化的作法，用更少量节点形成共识，以达到更高的性能。但这里就需要解决两个问题：  
1) 离散性：节点选择应该均匀分布，以达到更高的安全性，因为attacker不能集中攻击某一些节点以达到攻击目的。
2) 不可预测性：不能预测下一轮选择的节点，因为共识节点少了，如果能预测，攻击将变得非常简单。

Algorand使用"抽签"的方式选择每一轮的共识节点，"抽签"使用VRF算法，也是Algorand的亮点之一。  

这里假设现在要为N+1的block选择共识节点为例，主要流程如下：
1) 生成不可预测的随机数R：Algorand使用N block的seed，加上某种算法，得出一个在完成第 N block之前无法得知的随机数R，这个R在 N block生成之后，会被全网得知。
2) 每个帐户（用户）自己刮奖：使用自己的私钥与随机数R，用VRF算出一个hash，并将其拼到0后面，得到0.hash，所以刮奖号是[0,1]的一个区间。
3) 中奖后打包block：当用户发现自己的刮奖号(0.hash)<某个概率值，如10^-19，用户知道自己中奖了，然后他就可以进行打包操作。打包完后，将生成的[刮奖号，prove，包体]，发布到全网。
4) 验证者验证：验证者也是使用VRF选择出来的全链子集，验证者使用用户的public key，prove与随机数R进行验证，然后跑BA*算法...(不再展开)，达成共识，生成N+1的block。

##  总结

Algorand使用"抽签"的方式，用少量的节点，运行共识算法，以达到更高的性能。由于节点少，更中心化了，所以使用VRF来保证其安全性，包括离散性，不可预测性，可验证的特点。