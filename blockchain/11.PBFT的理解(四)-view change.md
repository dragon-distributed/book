# PBFT的理解四: View Change
(本文属于原创内容，首发于https://github.com/dragon-distributed/book , 未经作者许可，不得转载。)  

## 概述

本文重点讲解PBFT的View Change的部分。View Change部分本人觉得应该是PBFT中，最难以理解以及实现的。本文以New Primary的视角出发，尝试从需求的角度看为什么需要这样做View Change。   
(PS:本文讲的View Change是基于PBFT-PK实现的，即使用数字签字的方法实现的PBFT，以MAC的方式实现的View Change更加复杂，后面会有文章专门介绍)  

## 什么是View Change

可以理解为Raft的Leader切换，View是指Term的意思。View Change是保证liveness的重要手段。  

PBFT的view change，不像Raft是由当然节点的状态(log/term)等因素选举出来，而是类似是View mod NodeCount方式指定。所以，某个View的new primary，从全局来看，是固定的。    

## New Primary需要什么

如果你是新的primary，你要知道什么，你才能干活？我觉得应该有两点：    
(1) 前任干到了哪里（sequence number）
(2) 对于前任已经干过的事，是否是已经确认的? 比如每个事情（具体的sequence），是否ack client，内容是什么？是否有一些事情(某些sequence number)，是空洞的  

我们围绕这两点，去看看view change流程。  

## View Change流程

View Change的总体流程如下图：

![图1](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/11.overview.jpg)

### View Change阶段

当节点发现Primary异常时，节点就会往外广播："需要进行view change啦"。当new primary收到2f+1的相同的view change后，它就可以执行new view操作。这里的2f+1是包括自己，背后的意思是，从全局角度上看，多数派认为是需要进行view change。 

回到上面说的两点，new primary需要知道前任干了什么，干到哪里了。对于new primary，它只有自己的视图(数据)，它需要有人来告诉它，全局的视图是怎么样的，所以，需要在view change阶段，进行"合并统计"。也就是view change的广播，需要带上上述的信息。  

我们来看看view change消息的具体定义：

![图2](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/11.viewchange_message.jpg)

消息体的n, C, P都与"干了什么"有关系。回到节点的角度看，这个节点做到哪，则是由last stable checkpoint + checkpoint后续的sequence number相关。所以，view change消息中：
**(1) n：** 是此节点的last stable checkpoint中的sequence number
**(2) C：** stable certificate for stable checkpoint。为什么要这个呢，在[PBFT的理解(三)-garbage collection](!xx) 中有说明。简单来说明，就是在Byzantine环境下，需要有proof，才能证明这个checkpoint是正确的。所以C这里需要有f+1个proof  
**(3) P：** P是stable checkpoint之后的那些sequence number对应的request set。对于新primary来说，如果前任的request都是有效(ack client)的，则需要告诉其它节点，对齐一下，如果request是无效的，则需要对齐无效(no-op)。而新primary是不知道此request有没有ack client，那么，只要有可能ack的，都认为有效的，所以，只要有prepare certificate的，都是有可能ack的。而prepare certificate是指有一个pre-prepare message 加上 2f prepare message，所以P的消息如下所示：  

![图3](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/11.viewchange_message_P.jpg)

同样，2f prepare message + 1 pre-prepare message是在prepare阶段达成多数派的保证  


### New View阶段

当新Primary收到2f+1个相同的view change消息后(包括它自己)，则可以进入New View阶段。  

在最开始，new primary会拿到所有的view change消息，然后找出他们之中，最新的stable checkpoint(max n)，然后从n开始，处理n之后的每个sequence number。  

最新的stable checkpoint好找，只要找出view change消息中，sequence number值最大的checkpoint即可。但是，对于n后的sequence number，new primary需要创建一个pre-prepare message，message的值需要这样处理：  

(a) 对于n后的每一个sequence number，如果所有view change消息中，有这个sequence number，即有prepare certificate，则pre-prepare的值为填原请求的值。  

(b) 对于n后的每一个sequence number，如果所有view change消息中，没有这个sequence number，则pre-prepare的值为no-op。

new primary，将last stable checkpoint，以及后续的sequence number对应的pre-prepare meesage，装成new view message，广播给其它节点。new view message结构如下：  

![图4](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/11.newview_message.jpg)

其中，V是所有的view change消息，O则是上述的pre-prepare消息。  

**为什么需要V呢？**  
因为在Byzantine的环境下，new primary也需要有proof证明他这个new view是对的。  

**为什么需要pre-prepare呢？**  
上面说了，new primary需要让集群节点对齐sequence number，办法就是，让集群重新跑一次PBFT normal operation的4个步骤。大家可以想像成，new primary又重新做一次pre-prepare，跟client request处理一样。   

其它节点在收到new view的消息后，先验证这个消息的正确性，验证通过后，则开始执行new view操作。它会为new view中每个O集合中的pre-prepare消息，进行prepare广播，完成后进行view+1的切换。当然，如果节点数据不全，会进行learn操作(去其它replica同步数据)，这里就不展开了。

## 总结

当从new primary的角度出去，了解它做new primary需要什么数据，就比较容易理解PBFT的view change，然后再理解在Byzantine场景下，需要proof，那就能把PBFT的view change理解得更加深入。   