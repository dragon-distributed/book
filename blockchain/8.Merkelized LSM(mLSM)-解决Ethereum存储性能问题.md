# Merkelized LSM(mLSM)-解决Ethereum存储性能问题
(本文属于原创内容，首发于https://github.com/dragon-distributed/book , 未经作者许可，不得转载。)  

## 背景

Paper全称为：mLSM- Making Authenticated Storage Faster in Ethereum，是2018年在USENIX收录的一篇conference paper。  

Paper主要提出一个解决Ethereum存储性能的解决思路：Merkelized LSM，一种结合LSM以及Merkle Tree的数据存储结构。

Paper主要提出一种存储结构，一种思路，但对实现的细节并没有描述，这意味着，在工程实现上面必须得考虑更多。

## Ethereum存储性能问题

Ethereum的存储性能问题，主要有两个，一个是读写放大，另一个是缓存失效问题。

### 读写放大

可以阅读我之前发的文章：[ethereum storage analysis以太坊存储分析](https://github.com/dragon-distributed/book/blob/master/blockchain/1.ethereum%20storage%20analysis.md)。  

总的来说，Ethereum的MPT存在的严重的读写放大问题，极端情况下（如读写最底层的树节点），将会有64倍的读写放大问题。主要是：  
1) 写放大：一个node的写入，将要更新从这个node开始，一直到root的父节点。  
2) 读放大：主要问题是需要从root开始检索，而cache非常容易失效。 

如下图：  

![图1](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/8.write%20amplification.jpg)

![图2](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/8.read%20amplification.jpg)


### 缓存失效问题

缓存失效问题，主要是由于更新一个node，需要更新所有父节点的数据导致的。  

![图3](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/8.cache%20miss.jpg)

如上图所示，系统在缓存了四个key的情况下，如果将key为0x2f的value更新，则导致了现有缓存中的四个key都失效了。
 

## Merkelized LSM

mLSM借鉴了传统LSM的思想，将更新放在内存中，并且控制影响的范围，而同时，mLSM还保存了Merkle Tree的特性，让其保留了Proof。

mLSM的总体思想以及架构，可以从下图中看出：  

![图4](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/8.overall.jpg)

和LSM一样，由多级组成。  
1) **Memory Level:** Memory中存放的是多个Merkle Tree，当一个写入到达时，先写入Memory的Merkle Tree中。当Memory的数据达到一定的阀值时，将触发Compaction，写入到Level 1中。  
2) **其它Level:**  存放多棵Merkle Tree，也会触发Compaction。  

每一级，都能通过某种规则，得到此层的Root Hash，然后将多层的Root Hash计算出最顶层的Root Hash。

### 走出理解的误区

有技术背景，了解MPT的同学，可以在看这篇文章时，会觉得很奇怪，把MPT的知识套入mLSM，怎么都觉得不对。我们不妨换个思路。  
(PS：下面的讲解是基于我本人的理解，Paper中没有固定如何实现)  

![图5](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/8.mLSM%20explain.jpg)

整个树，是个Merkle Tree，但是，并不是整个树都是前缀字典树(trie)，而是每层的每一棵树才是MPT。

如果我们将LSM的level定义为6层，则可以想像成：root有6个叶节点，root的hash是由6个叶节点实时计算而成。而6个叶节点，固定为1-6的序列，每个叶节点，由每一层按某种规则计算出Hash。每一层有多个Merkle Tree + Trie的结合体(MPT)，完成数据存储与检索。  

### 数据写入

数据写入是直接写入到Memory中的，所以只会影响到level 0的hash以及root hash，其它每一层的hash不会变化。而由于level 0是memory的，所以存储很快，而且root是动态计算的，所以写入时，消耗很少（如果实现是WAL，则是一次的顺序写入，以及多数的内存计算）。  

写入影响如下图（绿色所示）：  

![图6](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/8.write%20impact.jpg)

### Compaction

在做compaction时，会影响两个level的数据，但其它level不受影响

### 数据读取

数据读取由level 0开始查找，实现可以使用Bloom Filter，如果level 0没有，则逐层往下找。

由于mLSM中，将原先Ethereum的整颗大树，分解成每一层的多个小树，所以有查找的性能上，会有所提升。

### 固定Compaction形为

root的hash由每一层hash得到，如果compaction的触发，区块链中，每个节点不一致的话，则每个节点的root hash不一致，导致无法进行validation。所以，在mLSM的实现中，需要固定Compaction的触发条件，让其工作得像"state machine"一样，有相同的input，做相同的compaction。  

## 结束语

mLSM是目前在区块链界中，比较务实的一个技术解决方案。相信在未来区块链的扩容提速中，这种存储结构会变得更加重要。