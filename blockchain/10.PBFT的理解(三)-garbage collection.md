# PBFT的理解三: Garbage Collection
(本文属于原创内容，首发于https://github.com/dragon-distributed/book , 未经作者许可，不得转载。)  

## 概述

本文重点讲解PBFT的GC的部分。GC部分的难点在于理解什么是stable checkpoint，为什么需要stable checkpoint。  

本文先介绍为什么需要GC，然后介绍PBFT中GC的流程。    

## 为什么需要Garbage Collection

这个跟传统的分布式系统，为什么需要做checkpoint或叫snapshot的原因是一样的，主要是：
1) 为了空间：可以删除历史的log文件，腾出空间
2) 为了快速同步：当其它节点有需要，可以直接从checkpoint中同步

## PBFT的checkpoint与传统分布式系统的checkpoint有什么不一样

这里说的传统分布式系统是非Byzantine的分布式系统，如基于Paxos协议的分布式系统。PBFT是Byzantine的分布式环境，BFT checkpoint的核心问题是，如何让其它节点相信这个checkpoint是正确的，比如，
* 当节点A需要从primary同步数据，那么如何让节点A信息这个primary的checkpoint是正确的
* 再如，要进行view change，backup A告诉新的primary，我的checkpoint是什么，但新primary如何信任你的checkpoint

解决这个问题的核心思想是proof。在提供checkpoint的同时，提供proof，去证明checkpoint是正确的。那么，这个proof最少有什么呢？我们带着这个问题看PBFT的checkpoint流程。    

## PBFT的GC流程

### checkpoint的生成

![图1](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/10.unstablecp.jpg)

每个replica，以每k个sequence number生成checkpoint，k是常量，如100，即sequence number为100,200,300时，生成checkpoint。在生成后，对checkpoint进行签名，并广播到其它节点，即完成生成流程。  
这时生成的checkpoint是unstable checkpoint，因为这个checkpoint没有办法让其它节点相信它是正确的，即没有proof。这时，replica是不能删除这个checkpoint之前的log的，因为这个checkpoint不可信。

### stable checkpoint的生成

每个replica的checkpoint生成逻辑是一样的，那么，在non-faulty的replica中，生成的checkpoint肯定是一样的。  

![图2](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/10.stablecp.jpg)

上文提到，在每个replica生成checkpoint后，会签名并广播，而相同的sequence number对应的checkpoint，其签名是一样的。在一个f tolerate的系统，如果一个checkpoint，能提供f+1个相同的签名并且是来自不同replica的，那么，我们可以认为这个checkpoint是可信的，也就是有proof。原因很简单，f+1中肯定有一个non-faulty的节点，他的checkpoint是可信的。  

一个checkpoint，如果有f+1个来自不同replica的相同签名，则认为这个checkpoint是有proof的。对于replica来说，如果他收到f+1个不同replica的相同checkpoint签名(包括它自己），则这个checkpoint是stable checkpoint(有proof)。replica有了新的stable checkpoint后，就可以删除这个checkpoint之前的log了。  

stable checkpoint除了用于同步，也用于view change，也是理解view change的核心。  

PBFT-MAC，基于MAC的PBFT实现，情况比PBFT-PK(数字签名)来的复杂。后续会单独介绍。  

## 总结

本文讲述了PBFT的Garbage collection，PBFT GC的重难点在于理解stable checkpoint，为什么需要proof。  












