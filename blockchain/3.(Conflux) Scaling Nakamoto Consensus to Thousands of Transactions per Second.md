# (Conflux) Scaling Nakamoto Consensus to Thousands of Transactions per Second

(本文属于原创内容，首发于https://github.com/dragon-distributed/book , 未经作者许可，不得转载。)  

## 背景

这篇paper是在2018.5.1在arxiv上发版的(v1版)，最新是v4版（在2018.8.31日更新）。作者都是华人，姚期智也在里面。Paper可以在https://arxiv.org/abs/1805.03870 中找到。  

Paper提出了一个名为Conflux的共识算法，它是一种快速，可扩展的共识算法，它可以乐观地并发处理block，延后定序确认，不会丢弃任何分叉。  

Paper中展示的实验数据，是在比特币源码的框架下实现的，根据实验数据的评估，在EC2 Cluster, 20K full nodes的场景下，throughput可以达到5.76GB/h, 大概是6400/tps (使用传统的Bitcoin transaction大小)。

本文尝试分析Conflux的核心思想，并分析主要流程。

## Conflux的核心思想

1) 与algorand、dfinit选择subset的机制不同， Conflux是全节点参与的。  
2) 使用DAG组织Blocks(选主链，定epoch等)。  
3) 乐观地并发处理transactions与blocks。  
4) 延迟确认transactions的全局顺序以及解决冲突。  

## 总体架构

在分析主要流程之前，需要先分析一下总体架构。下图是paper中的架构图：  

![图1](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/3.architecture.jpg)

图中，大虚线框外，是区块链中的每个节点（图中画了4个节点），大虚线框内，描述了一个block的生成过程：
1) 节点(node)通过网络收到tx9，并将其放收本地的transaction pool中。  
2) node从tx pool中拿取txs，并打包，计算hash(PoW)。  
3) 在成功算出hash后，更新本地的DAG，并将B广播出去。    

其它节点在接收到B后，更新本地的DAG，并通过几个核心算法，将其排列、定序。  

由于网络原因，每个节点的DAG在某个时刻可能不一样（比如在某一时刻，某个node某些block没收到），但随着时间的推移，总会趋向一致。由于排列、定序等算法是一致的，所以block的排列，tx的顺序等都最终趋向一致。  

## Local DAG in Conflux

下图是paper中举的local DAG的例子：  

![图2](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/3.local-DAG.jpg)

其中，conflux中将DAG的边(edges)分为两种：
1) Parent Edge：父链接，用实线表示，一个block只有一个父链接。
2) Reference Edge：引用链接，用虚线表示。引用链接用于表示"generated-before"关系，如上图中的E指向D，则表示D是在E之前生成。

下图将用实际例子来说明这个图的作用。

## Pivot Chain Selection (主链选择)

每个区块，有而仅有一个父区块，那么，在新区块生成的时候（挖矿），必须指定一个父区块。这个父区块必须是当前local DAG中的主链区块。所以，这里就涉及了主链选择问题：选择主链中的最后一个区块，作为要生成区块的父区块。

主链选择是有算法的，paper中的伪代码如下：

![图3](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/3.pivot.jpg)

这个公式是找出主链上，从区块b开始的链中，最后一个主链区块。公式中，关键在于第8行，下个区块有两个关键的考虑条件：
1）确认子区块最多的，作为主链
2) 如果子区块相同，则使用hash值小的区块作为主链。

按上面的DAG图，Genesis有两个子区块，A与B，那么选哪个是主区块呢？那就首先看A的子区块多还是B的子区块多，显然，是A，所以A是主链上的区块。那新区块C，则父区块应该为A。  

那为什么F的父区块是B，而不是C呢？按逻辑，F应该选主链的区块作为父区块才对。前面说了，在某一时刻，每个节点的local DAG是不一样的，在生成F的节点，当时计算出的父区块就是B，只是在后续的不段同步过程中，B变成了支链节点。


## The Conflux Main Loop

![图4](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/3.main-loop.jpg)

Conflux的主流程主要有两个：  
1) 生成区块：生成区块，更新local DAG，并广播出去
2) 接收DAG update消息：接收DAG update消息，并更新本地DAG

上图中的伪代码是广播DAG，但论文中有特别提及："Note that for brevity, the pseudo-code in Figure 5 broadcasts the whole graph to the network. In our Conflux implementation, Conflux broadcasts and relays each individual block to avoid unnecessary network transmissions. "

## Block Total Order（区块排序）

Pivot Chain Selection用于决定主链，Total Order用于计算block的epoch。paper中的伪代码如下：

![图5](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/3.conflux-order.jpg)

意思是给定一个local DAG，以及在主链上的block a，算法计得到block a之前的，已经定序的，划分好epoch的block list。如Genesis，（A），（B，C），（D，F，E）...  

关键的代码是第4行，表示递归查找前一个block，直到前一个block是Genesis为止。假设a'是a的父区块，第5行表时，找到a'到a之间生成的blocks，也就是a所在epoch的blocks。6-12行将这些blocks进行排序，并输出。

回到最开始的local DAG图，D,F属于epoch-E，是因为D,F是在E之前生成的，属于C-E之间的区块。J为什么属于epoch-H而不是epoch-E呢，是因为J比E后生成。


## Transaction Total Order

由于conflux的核心是乐观地并发处理transactions与blocks，以及延迟确认transactions的全局顺序以及解决冲突，所以同一交易可能会打包在不同的block中，而且不同的交易可能会有冲突(冲突是指无效/无法完成的交易，如余额不足等)。
在对block进行定序之后，不同block之间的交易，按block的顺序排序，对于同一block中的交易，按照交易顺序排序。对于相同的或者有冲突的transaction，只处理第一个。

回到local DAG图, 交易最终顺序为：Tx0, Tx1, Tx2, Tx3(no-valid), Tx4-in-B, and Tx4-in-G(no-valid)。Tx3无效是指与Tx2冲突了(X不够钱了)，Tx4-in-G是因为相同的交易无效。

## 安全性

延续PoW的特性，只要算力不超过50%，都认为是安全的。为什么是50%，可以参考我的另一篇文章 [区块链的一些机制 - 从double spend(双花攻击)问题说起](https://github.com/dragon-distributed/book/blob/master/blockchain/2.区块链的一些机制-从double%20spend(双花攻击)问题说起.md)


## 总结

Conflux乐观地认为，transaction在不同的blocks是没有冲突的，所以在生成block时，不管transaction是什么，先打包了再说，再由后续的DAG对block进行定序，对transaction进行定序，延迟解决冲突。由于DAG的存在，没有分叉的说法，不需要丢弃blocks。

(PS: Conflux的思路，跟EPaxos有点相似，都是使用类似DAG延时定序，执行)