# PBFT的理解(一) ：介绍及常见问题 (Practical Byzantine Fault Tolerance)
(本文属于原创内容，首发于https://github.com/dragon-distributed/book , 未经作者许可，不得转载。)  

## 背景

分布式系统从小世界（能自己全盘控制）走到大世界（广域网的世界），所面临的挑战是完全不同的。  

小世界里面的人(node)，都是善良的，他们可能会不回消息，或者延时回你消息，但是他不会说慌，但大世界就不一样了，充满着形形色色的人，他们可能会回你ok，但自己做不干事（说一套做一套），或者他可能跟你说某事件达成共识是甲，转头又跟别人说乙（墙头草），更恶劣的是专门干坏事的，比如欺骗你。  

在小世界里，使用如paxos、raft、zab就可以让一群人(cluster)达成共识，但在大世界里，就需要如Byzantine Raft，PBFT等能容忍拜占庭的一致性协议，才能让一群人达成共识。

PBFT的论文是在1999年发表的，近20年没有被广范应用，除了计算机技术发展外，个人认为PBFT有他自己的"落地悖论"：如果集群大，则PBFT会受性能问题的制约，但如果集群小，又可以把他控制在小世界的范围内，可选的算法太多，没必要使用它。但随着区块链的发展，Algorand中提出使用"选子集"跑BFT的思想，越来越多系统考虑使用PBFT作为区块链的共识算法，PBFT也走向了大家的视线。

## PBFT算法组成

PBFT主要由三大块组成，分别是：

1) 共识流程(normal-case operations)：主要是指从接收到client request，到复制，到达成共识，ack client的流程。
2) View Change：主要是指Primary异常时，换Primary的过程，可以看成是Raft的Leader Change，View可以看作是Term。View Change也是保证liveness的关键。
3) Garbage Collection（GC）：可以看作是节点做snapshot，但与raft不同，它分stable checkpoint以及non-stable checkpoint，stable checkpoint需要多节点交互成生proof，以便view change使用。

其中，View Change是PBFT最难的地方，后面会有专门的文章详述。  

在详述三大块前，想先介绍一下pbft的一些关键点：  

1) f 究竟是什么？  
2) 为什么是集群节点数n=3f+1  
3) 为什么prepare是2f  
4) 为什么commit是2f+1  
5) 为什么client是f+1

## 关键点
### f 究竟是什么？为什么是集群节点数n=3f+1

首先我们先来了解raft/paxos这种非Byzantine算法，为什么是n=2f+1。在非Byzantine的场景下，假设有n个节点，突然倒下了f个，那么只要剩下的节点大于f+1个(多数派)，则可以达成共识，所以n>2f，推导出n>=2f+1，按最少成本算，n=2f+1。举个例子，比如有5个节点，倒了2个，只要有>2的节点(3个)存在，就能达成多数派，如果倒了3个，剩下2个，则达不到多数派。  

但在Byzantine的场景下，我们不能这样理解。我们先看1999年的paper原文：
"The resiliency of our algorithm is optimal: 3f+1 is the minimum number of replicas that allow an asynchronous system to provide the safety and liveness properties when up to f replicas are faulty (see [2] for a proof). This many replicas are needed because it must be possible to proceed after communicating with n-f replicas, since
replicas might be faulty and not responding. However, it is possible that the f replicas that did not respond are not faulty and, therefore, f of those that responded might be faulty. Even so, there must still be enough responses that those from non-faulty replicas outnumber those from faulty ones, i.e., n-2f>f . Therefore n>3f."

理解这段文字的关键是"did not respond"，我们将节点分为faulty与non-faulty的节点，而"did not respond"有可能是这两种节点的其中一种。"did not respond"只是表达slow的概念，并不是crash，所以，**f表示同一个时刻，最多只有一个faulty节点，无论这个节点是crash(永久性not respond)或者是恶意节点**

在极端的情况下，为了保证safety"did not respond"节点f个（他只是暂时不回复），但作恶的f个节点有回复，这种情况下，是不能让其达成共识的，所以需要剩下的节点大于f+1个，所以n>3f，推导出n>=3f+1，n=3f+1。 等"did not respond"恢复了，集群也就恢复正常了。  

值得注意的是，"did not respond"不是一直不回复的，不然就玩不转了。

paper作者的博士论文，还有一种解析，是从liveness的角度出发的，从Write Set与Read Set的角度从计算n值，这里不再展开。    


### 为什么client是f+1

对于client来说，收到f+1的ack，说明最少有一个诚实节点的，那么这个节点保证了这个请求在多数派达成了一致(已commit)，也保证了正确性。

### 为什么prepare是2f，commit是2f+1

正确回复client的request，保证了最少有一个non-faulty节点给client发送了reply，从这个节点的视角上看，这个节点是需要有commit certification的，也就是说，他需要保证他收到了多数派的commit，也就是2f+1个commit。

prepare跟commit的思想差不多，但区别就是，primary是默认接受prepare的，也就是在primary发送pre-prepare消息时，就代表他接受了prepare了，其它replica节点，接收了其它的2f个，加上primary也是2f+1个了。  

## 结束语

本文介绍了PBFT，以及PBFT的一些常见问题，normal-case operation/view change/gc的具体流程请见后续文章。  

## 共识流程

Normal case的共识流程主要有五个步骤，paper写得比较清楚，如下图：

![图1](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/5.pbftprocess.jpg)

a) **client发送请求到primary**。  
b) **pre-prepare:** 一旦primary收到request，它会做三件事：  
     b1) 给request定序(the primary assigns a sequence number, n , to the request)  
     b2) 广播pre-prepare(包括view number(类似raft term), sequence number(类似raft index), request, 签名等信息)  
     b3) 将pre-prepare message存储到本地的log  
c) **prepare:** 其它backups收到pre-prepare message之后，会进行校验。如果校验通过，则将prepare message存储到本地的log  
d) **commit:** 当backups收到包括自己的2f个有效的prepare消息之后，它开始commit阶段的流程，广播commit消息。其它节点收到commit消息后，进行校验，随后存储到本地的log。  
e) reply：当backup收到包括自己的2f+1个有效的commit消息后，执行request，并reply给client，这跟raft的apply是一样的   

这里的每一步都要存储log，在工程实现中，需要考虑采用什么存储方式，可以减少disk io操作，一来提升性能，二来省存储空间。

## Garbage Collection（GC）

跟raft的snapshot一样，总不能让log不断增长，要生成一个snapshot，包括状态机的一个dump跟一个log的位点，然后删除这个位点前的log。  

在raft算法中，由于没有Byzantine，所以节点可以自己生成snapshot，其它节点在恢复时，认为只要是snapshot都是有效的（诚实的）。但PBFT不一样，节点在用snapshot时，必须有办法证明此snapshot是有效的（诚实的），所以PBFT在生成snapshot时，必须有proof。  




## View Change

与raft一样，view change是由backups发起的，backup收到request请求（无论是client发的request，还是primary广播的pre-prepare），都会启动timer，当一定时间无法进行execute后，会进行view change操作
1）view change: 当backup认为primary异常时(crash or 作恶)，backup会向其它节点广播view-change的消息。view change作将view number + 1，这与raft是一致的
2) new view: 当有节点时收到2f+1个view change消息时(包括他自己)，则进行new view操作，该节点广播new view message到其它节点。其它节点收到new view message后，进行校验，通过后进行PBFT的prepare流程，直到reply

View Change以及GC在工程实现上，应该远没有paper描述的那么简单，应该结合源码，或者自己实现一次，会更深入了解。

## 总结

本文首先描述了PBFT的一些关键点，为什么是3f+1, 2f+1以及f+1，这对了解PBFT比较关键，特别是对于有分布式算法基础的人。后续简单介绍了PBFT的三个主要流程。  

另外，本人计划再深入写view change以及GC的思想以及流程












