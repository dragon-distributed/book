
# ethereum存储分析

(本文属于原创内容，首发于https://github.com/dragon-distributed/book , 未经作者许可，不得转载。)  

本文将以举例的方式，讲解  
1) Level DB是如何存储MPT tree  
2) State Trie ( Account ) 的存储，以及多版本  
3) Contract本身的存储  
4) Contract数据的存储  
5) ethereum性能问题分析  

本文以go版本的ethereum进行分析。

## Level DB是如何存储MPT tree

Level DB存储MPT的细节资料，网上比较少。笔者通过阅读代码、分析数据得出相关的结论，下面将举例说明：    

**假设现在需要往MPT中插入dog, doc两个key，value分别为v1，v2。那么，存储结果如下图：**  

![MPT LevelDB](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/1.MPT.jpg)

由上图可以看出几个关键点：  
1) MPT Node中的标识是它的hash，而hash则是node的rlp编码后，再进行hash得到的值。  
2) LevelDB存储key是Node的hash，Value则是node rlp编码后的数据。  
3) Node除了hash，还包括node的类型，对子节点的指针，或者value bytes，这里不重点关注。

## State Trie ( Account ) 的存储，以及多版本

**假设有account aa与ab，在block N中创建，在block N+1中，更新了account ab，则对应的情况如下图：**  

![state trie](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/1.state%20trie.jpg)

由上图可以看出几个关键点：  
1) 在block N时，LevelDB存储了key为0x11,0x22,0x33的三对key value，其中0x33为block N的root hash，通过这个hash，可以找到block N对应的account状态(可以想像为version为N的account状态)。  

>搜索一个account(eg: eth.getAccount)，具体步骤为：  
>a) root hash from level db(0x33)     
>b) decode root node  
>c) find child hash(0x22-0x33)  
>d) get child hash from level db(假设是0x22)  
>e) decode 0x22 node  
>f) 得到account  

2) 在block N+1时，更新account ab，由于ab的account发生变化，所以hash(rlp(node))会发生变化，这里假设计算出hash为0x44。  

由于MPT的性质，root hash必然发生改为，假设计算出为0x55。 

那这时，LevelDB存了5个key，在block N来看，account aa, ab的数值为0x33查找到的0x11, 0x22，而从block N+1来看，account aa, ab的数值为0x55查找到的0x11与0x44，实现了多版本或者说是blockchain的特性。  

从LevelDB看，这五条数据都是有用的，用于blockchain追溯历史。  

## Contract本身的存储 

contract代码的存储比较简单，因为contract本身是一个account，所以它存储在account之中。如下图：

![contract](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/1.contract.jpg)

从图中可以看出，contract本身是account的一个特例（不严谨的说法），contract code存储在account之中，**也就是说，contract code会被rpl到node之中存储，不会被LevelDB单独存储（如特殊的key存contract code之类的）**

## Contract数据的存储

contract数据的存储，又是另一棵MPT。如下图所示：  

![contract data](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/1.contract%20data%20storage.jpg)

这里有几个关键点：  
1) contract account中，存储了contract storage trie的root，就像block header存储state trie的root一样。

2) 多版本实现：像account多版本一样，通过block N找到对应的contract account，而contract account又对应版本的contract storage trie。  

也就是说，不同block的contract存储数据，是通过block header state trie root找到对应的contract account从而定位到对应的contract storage trie。

3) key存储与state trie不同：与account存储不同的是，state trie中，key是address，而contract storage trie，存的不是智能合约中的key->value的真实数据，而是经过hash编码的，好处是固定了key的长度。

## ethereum性能问题分析

简单从下图就可以得出：

![contract data](https://longdandan-1256672193.cos.ap-guangzhou.myqcloud.com/article/blockchain/1.performance%20problem.jpg)

1) 更新一个account，会更新从这个account到root的整条路径的节点，按go ethereum现有的组织方式，大概最大的树高是16（非精确值），也就是最极端的情况，更新一个account，需要做16次LevelDB操作。

2) 更新contract的一个数据(insert/update/delete)，性能损耗更高，需要更新storage trie，而且需要更新对应的contract account，也就是state trie也需要更新。

ethereum的性能问题的解决方案，其中有一篇paper写得非常不错，下次专门写一篇进行介绍。  


