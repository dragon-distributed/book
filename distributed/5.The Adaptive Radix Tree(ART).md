# The Adaptive Radix Tree (ART)

(本文属于原创内容，首发于https://github.com/dragon-distributed/book , 未经作者(龙永超)许可，不得转载。)  

## 背景

我的上一篇文章In Search of a Key Value Store with High Performance and High Availability中，介绍了Log as Database的一个分布式KV存储：LogStore，其内存Index是用Adaptive Radix Tree存储的，为什么要用Adaptive Radix Tree？本篇文章将介绍一下Adaptive Radix Tree。  

## Radix Tree

讲Adaptive Radix Tree之前，先简单讲讲Radix Tree。以下内容抄自Wiki:  

在计算机科学中，基数树，或称Patricia trie/tree，或crit bit tree，压缩前缀树，是一种更节省空间的Trie（前缀树）。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。如下图所示：  

[图1]

我们常常叫Trie为字典树。Radix Tree在计算机中有很广泛的应用，如在Linux的内存管理。  

## Adaptive Radix Tree

Radix Tree最大的问题是存储空间上。Paper中给出的例子：  

[图2]

其中，图中的s的意思是，每个node存储多少个bit的数据。如s=1时，即每个inner node存储1 bit的数据。  
上图的数据，是指在存储100万个不同的32 bit integers的场景中，在不同的s下，不同的内存消耗。从图中可以看出，如果s=1时，即树高32，需要最少的内存。随着s增大，内存量不断地增大，在s=8，即每个node存一个char时，需要>128MB的内存量，当s=32时，需要>32GB的内存。  
然而，Radix Tree的搜索性能跟树高是有关系的，s=1时，内容最少，但树最高。所以在使用Radix Tree时，需要tradeoff性能以及存储。  

Adaptive Radix Tree使用可变的(adaptive) nodes解决上述问题。从上图中可以看到，ART在s=8时(本人观察结果，paper中并未具体指出)，内存从Radix Tree的200MB缩减到30MB左右。  

## Structure of Inner Nodes

Adaptive Radix Tree使用s=8的情况设计(理解为刚好char的大小)。它将一个Inner Node分别两部分，一部分是Key，一部分是Pointer。Inner Node有4种规格的Inner Nodes，分别是Node4, Node16, Node48, Node256，我们分别解析一下：  

[图3]

**Node4 & Node16：**  这两种Node，每个Node可以存4/16个Key，可以简单理解成vector<char>(4)与vector<char>(16)，当然Pointer也是4与16个。其中, Key的检索可以使用类似二分法进行。  

**Node48：**  Node48比较特殊，其中Key部分是256个，Pointer部分是48个，即 key vector<char>(256)，vector<pointer>(48)。为什么呢？这是出于性能的考虑，如果Key是48个的话，对于Key的检索开销就比较大。为什么要用256个key呢，因为s=8的情况下，一个key的取值刚好是256，刚好可以用下标直接定位。  

**Node256：** Node256只有Pointer部分，没有Key部分，Pointer与Key的对应，则是用下标直接对应。  

Adaptive Radix Tree会优先使用小的Node，即Node4。当空间不足时，将替换成较大的Node，如Node16。通过这种方式存储空间的优化。  

## Structure of Leaf Nodes

Leaf Node用于存储Key对应的value。比较简单，Paper中讲了三种leaf类型：  

**Single-value Leaves：** 一个单独存储value的leaf类型  
**Multi-value Leaves：** 像Inner Node4类似，只是它存的不是4个Pointer而是Value  
**Combined pointer/value slots：** 就是又存指针又存value的节点。  

## Collapsing Inner Nodes

当一个长长的key插入到Adaptive Radix Tree中时，就会使树变得很高。well-known的方法有两个：  

[图4]

**lazy expansion：** 如图所示，FOO的存储，直接把OO给折叠了，当后续有FOX的Key插入时再展开。  

**Path compression：** 如果path中有相同的key，则可以压缩。Paper介绍了两种方法，一种是悲观的方法，即路径中存了具体的key，比如图中的A。另一种是乐观的方法，即只存有合并了多少个key，但要在leaf key中对比，比如图中，不存A，只存"合并了一个key"，到叶子节点，如BAR，再去比较A。  

在实际使用中，可以考虑综合的办法，如文中说的hybird approach，每个node有固定的8 bytes的存储，用于悲观方式，但超过8 bytes之后，就切换成乐观的方式。  

## 总结

LogStore中，所有的Key的index，均需要存储在内存当中，所以对存储空间要求较高。而且对于Key/Value存储系统，对于Key的检索性能要求也很高。Adaptive Radix Tree具备很高的检索性能，以及较少的存储空间，非常适合类以LogStore这样的存储系统。  
LogStore也有自己的缺点，它在scan的性能并没有B+ Tree这么高，因为它并没有兄弟之间的指针，在scan占比较高的场景，实现Adaptive Radix Tree时，可以考虑把兄弟指针加上。