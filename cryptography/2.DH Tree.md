# DH Tree

(本文属于原创内容，首发于https://github.com/dragon-distributed/book , 未经作者(龙永超)许可，不得转载。)  

## 背景

最近在看E2EE，又发现了好玩的东西，记录下来。  

大家知道，在不可信的网络中，双方要协商一个密钥，可以使用Diffie-Hellman (DH) 方式协商， 基于Elliptic Curve的DH则叫ECDH。其背后的数学原理，可以看wiki了解。但从实现上，简单来说，就是用A的私钥+B的公钥，算出的一个密钥，跟用B的私钥+A的公钥算出的密钥是一致的。  

在一对一的通信中，DH应用非常广泛，如TLS，加密通信都有它的身影。一些实现上常见的用法是，A生产临时公私钥对，用私钥+B的公钥算出密钥，使用密钥对信息加密，最后把ciphertext以及公钥发送给B，B使用自己的私钥即可解密。之后，B可以使用自己的私钥跟传过来的公钥，算出密钥与A进行加密通信，B也可以生成临时的公私钥对再跟A通信。著名的Signal有X3DH协议，可以看作是DH的放大三倍版本（^_^安全性），达到FS/PFS(prefect forward secrecy)以及PCS(Post-compromise secrecy)。 

但在群组的情况下，如何让群成员共享一个密钥，又很方便地更改密钥呢？比如基于安全的考虑，有新成员进群，或者成员离群，密钥需要改变，有没有好的办法？  

## DH Tree

DH Tree首先是一棵二叉树，是一棵基于DH算法算出来的二叉树。在群组的应用场景中，每个叶子节点，可以想像成是一个群成员，群成员有自己的公私钥。群成员可以使用自己的私钥，解出这棵树的root节点的密钥。如下图所示：  

[图一]

上图中，有四对key pairs，ABCD，两两做DH，得到两个父节点，两个父节点在做DH，得到Root节点。对于这棵DH tree，只要知道ABCD之中任意一个private key，则可以解出Root。  

## DH Tree Initialize

在上述的例子，要生成一个ABCD的DH Tree，需要AB中的其中一个以及CD中的其中一个同时在线，因为只有这样，AB才能DH，CD才能DH。但如果放在群组的应用场景，这更多的是群组创建过程，这时要求群组成员在线，显然不太合适。  

DH Tree有另一种创建过程，可以让创建者直接创建一棵多层的DH Tree，过程如下（下述例子假设A是创建者）：
1) A创建三个临时的Key pairs，对应B'C'D'。  
2) A用自己的私钥与B'C'D'作DH，计算出三个密钥, X,Y,Z。  
3) 使用X,Y,Z生成三个key pairs，对应EB,EC,ED。  
4) A用自己的私钥，与EB,EC,ED进行DH，生成DH Tree (注，以上2-4步，papre中叫Key Exchange协议，为了简化说明，我使用了DH的说法更好理解)

对于B来说，上线之后，它可以用自己的私钥，与A的公钥进行DH，得到X，然后计算出EB，得到EB对应的key pair，解出root。

## DH Tree Update

对于B来说，如果要更新DH Root，则B生成新的key pair，与A做DH，一直更新到Root，如下图所示：  

[图二]

对于A,C,D，只要用自己的私钥，则可以计算出DH Tree的Root。  

## 总结

本文简单介绍了DH Tree，并简要介绍了DH Tree的思想，树的初始化与更新操作，以及DH Tree在群密码的应用。如果需要再详细了解，可以看看paper：On Ends-to-Ends Encryption。  
